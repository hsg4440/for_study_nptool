/*****************************************************************************
 * Copyright (C) 2009-2014    this file is part of the NPTool Project        *
 *                                                                           *
 * For the licensing terms see $NPTOOL/Licence/NPTool_Licence                *
 * For the list of contributors see $NPTOOL/Licence/Contributors             *
 *****************************************************************************/

/*****************************************************************************
 * Original Author: Adrien MATTA  contact address: a.matta@surrey.ac.uk      *
 *                                                                           *
 * Creation Date  : march 2025                                               *
 * Last update    :                                                          *
 *---------------------------------------------------------------------------*
 * Decription:                                                               *
 * Class describing the property of an Analysis object                       *
 *                                                                           *
 *---------------------------------------------------------------------------*
 * Comment:                                                                  *
 *                                                                           *
 *                                                                           *
 *****************************************************************************/
#include "NPSystemOfUnits.h"
#include <TUrl.h>
#include<iostream>
using namespace std;
#include"Analysis.h"
#include"NPAnalysisFactory.h"
#include"NPDetectorManager.h"
#include"NPOptionManager.h"
#include"RootOutput.h"
#include"RootInput.h"

#include "TMath.h"
////////////////////////////////////////////////////////////////////////////////
Analysis::Analysis(){
}
////////////////////////////////////////////////////////////////////////////////
Analysis::~Analysis(){
}

////////////////////////////////////////////////////////////////////////////////
void Analysis::Init(){
    //--> Detector physics
    fM2 = (TMust2Physics*) m_DetectorManager->GetDetector("M2Telescope");
    fCATS = (TCATSPhysics*) m_DetectorManager->GetDetector("CATSDetector");
    //IC, Plastic and TOF from CATS
    fModularLeaf = (TModularLeafPhysics*) m_DetectorManager->GetDetector("ModularLeaf");
    //--> ROOT I/O
    InitOutputBranch();
    InitInputBranch();
    //--> Auxiliar funcs and variables for analysis
    fReaction= new NPL::Reaction();
    fTargetThickness = m_DetectorManager->GetTargetThickness();
    //	Energy loss table: the G4Table are generated by the simulation
    fHe3CD2 = EnergyLoss("./energy_loss/He3_CD2.G4table","G4Table",10 );
    fHe3Al = EnergyLoss("./energy_loss/He3_Al.G4table","G4Table",10);
    fHe3Si = EnergyLoss("./energy_loss/He3_Si.G4table","G4Table",10);
    fBeamCD2 = EnergyLoss("./energy_loss/Be12_CD2.G4table","G4Table",10);
    fBeamMylar = EnergyLoss("./energy_loss/Be12_Mylar.G4table","G4Table",10);
    fBeamIsobutane = EnergyLoss("./energy_loss/Be12_iC4H10_0.008bar_273.15K.G4table","G4Table",10); 

}

void Analysis::TreatBeam()
{
    //--> Get beam vertex and direction
    XYZPoint vertex {fCATS->GetPositionOnTargetX(), fCATS->GetPositionOnTargetY(), 0.};
    XYZVector beamDirection {fCATS->GetBeamDirection()};
    mThetaBeam = ComputeXYZVectorAngle(beamDirection, XYZVector(0, 0, 1));
    //--> Beam energy CALIBRATION
    mCATS1Calibrated = fModularLeaf->GetCalibratedValue("T_CATS1_CAV");
    double beamSpeed { 11.0476 + mCATS1Calibrated * 0.278917}; // mm/ns
    //work in SI units
    beamSpeed *= 1.E6; //1.E9 * 1.E-3 m/s
    // Beam Energy before CATS1
    static double kCSquared {TMath::Power(TMath::C(), 2)};
    auto gamma0 {ComputeGamma(beamSpeed)}; 
    mEBeam = kBeamMass * (gamma0 - 1);

    //debug
    // std::cout<<"Beam speed  = "<<BeamSpeed<<'\n';
    // std::cout<<"Beta        = "<<beta<<'\n';
    // std::cout<<"Gamma       = "<<gamma<<'\n';
    // std::cout<<"Beam energy = "<<BeamEnergy<<'\n';
                
    // Energy Loss in CATS1         
    double beamAfterCATS1 {ComputeELossInCATS(mEBeam, mThetaBeam)};
    XYZPoint pointCATS1 {fCATS->PositionX.at(0), fCATS->PositionY.at(0), fCATS->PositionZ.at(0)};
    XYZPoint pointCATS2 {fCATS->PositionX.at(1), fCATS->PositionY.at(1), fCATS->PositionZ.at(1)};
    //Time correction in space between CATS1 to CATS2
    mTimeCorr = ComputeTimeCorrectionInCATS(beamAfterCATS1, kBeamMass, pointCATS1, pointCATS2);
          
    // ELoss in CATS2
    double beamAfterCATS2 {ComputeELossInCATS(beamAfterCATS1, mThetaBeam)};
    //Time correction
    mTimeCorr += ComputeTimeCorrectionInCATS(beamAfterCATS2, kBeamMass, pointCATS2, vertex);

    // Slow down beam inside the target
    mEBeam = fBeamCD2.Slow(beamAfterCATS2, fTargetThickness * 0.5, mThetaBeam);

    //--> Set kinematic calculator
    fReaction->SetBeamEnergy(mEBeam);
}

////////////////////////////////////////////////////////////////////////////////
void Analysis::TreatEvent(){
    // Reset saved variables
    ReInitValue();
    
    // Calculate Run Number
    static string filename ;
    filename = RootInput::getInstance()->GetChain()->GetFile()->GetName();
    size_t minor_pos = filename.rfind("_");
    mRunMinor = atoi(filename.substr(minor_pos+1,1).c_str());
    filename = filename.substr(0,minor_pos);
    size_t major_pos = filename.rfind("_");
    mRunMajor = atoi(filename.substr(major_pos+1,4).c_str());
    
    // Get the Init information on beam position and energy
    // and apply by hand the experimental resolution
    // This is because the beam diagnosis are not simulated
    // PPAC position resolution on target is assumed to be 1mm
    //------------------- BEAM ---------------------------
    XYZPoint vertex {fCATS->GetPositionOnTargetX(), fCATS->GetPositionOnTargetY(), 0.};
    XYZVector beamDirection {fCATS->GetBeamDirection()};

    bool computeBeam {true};//just do this one time if cuts are passed
    //////////////////////////// LOOP on MUST2 Hit /////////////////
    for(unsigned int hit = 0 ; hit < fM2->Si_E.size() ; hit++)
    { 
       
        int telescopeNumber {fM2->TelescopeNumber.at(hit)};
        XYZPoint must2Point {fM2->GetPositionOfInteraction(hit)};

        //cut on telescope number
        if(!(telescopeNumber < 9))
            continue;
        //cut on vertex position
        if(!(vertex.X() > -1000 && vertex.Y() > -1000))
            continue;

        // // Beam computation (ONCE per event)
        // if(computeBeam)
        // {
        //     TreatBeam();
        //     computeBeam = true;
        // }
        mThetaBeam = ComputeXYZVectorAngle(beamDirection, XYZVector(0, 0, 1));
        //--> Beam energy CALIBRATION
        mCATS1Calibrated = fModularLeaf->GetCalibratedValue("T_CATS1_CAV");
        double beamSpeed { 11.0476 + mCATS1Calibrated * 0.278917}; // mm/ns
        //work in SI units
        beamSpeed *= 1.E6; //1.E9 * 1.E-3 m/s
        // Beam Energy before CATS1
        static double kCSquared {TMath::Power(TMath::C(), 2)};
        auto gamma0 {ComputeGamma(beamSpeed)}; 
        mEBeam = kBeamMass * (gamma0 - 1);

        //debug
        // std::cout<<"Beam speed  = "<<BeamSpeed<<'\n';
        // std::cout<<"Beta        = "<<beta<<'\n';
        // std::cout<<"Gamma       = "<<gamma<<'\n';
        // std::cout<<"Beam energy = "<<BeamEnergy<<'\n';
                
        // Energy Loss in CATS1         
        double beamAfterCATS1 {ComputeELossInCATS(mEBeam, mThetaBeam)};
        XYZPoint pointCATS1 {fCATS->PositionX.at(0), fCATS->PositionY.at(0), fCATS->PositionZ.at(0)};
        XYZPoint pointCATS2 {fCATS->PositionX.at(1), fCATS->PositionY.at(1), fCATS->PositionZ.at(1)};
        //Time correction in space between CATS1 to CATS2
        mTimeCorr = ComputeTimeCorrectionInCATS(beamAfterCATS1, kBeamMass, pointCATS1, pointCATS2);
          
        // ELoss in CATS2
        double beamAfterCATS2 {ComputeELossInCATS(beamAfterCATS1, mThetaBeam)};
        //Time correction
        mTimeCorr += ComputeTimeCorrectionInCATS(beamAfterCATS2, kBeamMass, pointCATS2, vertex);

        // Slow down beam inside the target
        mEBeam = fBeamCD2.Slow(beamAfterCATS2, fTargetThickness * 0.5, mThetaBeam);

        //--> Set kinematic calculator
        fReaction->SetBeamEnergy(mEBeam);
    
        XYZVector trackDirection {must2Point - vertex};
        // Angles computation
        mThetaLab.push_back( ComputeXYZVectorAngle(trackDirection, beamDirection) );             
        double mNormalThetaTarget = ComputeXYZVectorAngle(trackDirection, XYZVector(0, 0, 1));
        double mNormalThetaM2 = ComputeXYZVectorAngle(trackDirection,
                                                      -1 * XYZVector(fM2->GetTelescopeNormal(hit)));
        
        // Save hit position (can't be accessed afterwards if not done here)
        mMust2Telescopes.push_back( telescopeNumber );
        mMust2PointsX.push_back( must2Point.X() );
        mMust2PointsY.push_back( must2Point.Y() );
        mMust2PointsZ.push_back( must2Point.Z() );
                           
        //Assume CsIE == 0!
        double EAtDetector { fM2->Si_E.at(hit) };
        //Save energies to custom branches
        mMust2SiE.push_back( fM2->Si_E.at(hit) );
        mMust2CsIE.push_back( fM2->CsI_E.at(hit) );
        mMust2SiT.push_back( fM2->Si_T.at(hit) );
        
        //Backpropagate to vertex
        double ELabIni {fHe3Al.EvaluateInitialEnergy(EAtDetector, 0.4 * micrometer, mNormalThetaM2)};
        //Assume reaction at the middle of target and correct energy
        mELab.push_back( fHe3CD2.EvaluateInitialEnergy(ELabIni, fTargetThickness / 2., mNormalThetaTarget) );
        //Compute Excitation Energy
        mEx.push_back( fReaction->ReconstructRelativistic(mELab.back(), mThetaLab.back()) );
        //std::cout<<" Ex = "<<mEx.back()<< "MeV"<<'\n';
        // Back to CM
        mThetaCM.push_back( fReaction->EnergyLabToThetaCM(mELab.back(), mThetaLab.back()) / deg );//in degrees
        mThetaLab.back() =  mThetaLab.back() / deg ;//store in degrees!
        //debug
        std::cout<<" EAtSil = "<<EAtDetector<<'\n';
        std::cout<<" E1     = "<<ELabIni<<'\n';
        std::cout<<" EVert  = "<<mELab.back()<<'\n';
        std::cout<<" Theta  = "<<mThetaLab.back() * TMath::RadToDeg()<<'\n';
        std::cout<<" Ex     = "<<mEx.back()<<'\n';
    }
    //ensure
    if(!(mEx.size() == mThetaLab.size()))
        throw std::runtime_error("Mismatching sizes for Eex && thetaLab vectors!");
}

////////////////////////////////////////////////////////////////////////////////
void Analysis::End(){
}

////////////////////////////////////////////////////////////////////////////////
void Analysis::InitOutputBranch() {
    RootOutput::getInstance()->GetTree()->Branch("Ex", &mEx);
    RootOutput::getInstance()->GetTree()->Branch("ELab", &mELab);
    RootOutput::getInstance()->GetTree()->Branch("ThetaLab", &mThetaLab);
    RootOutput::getInstance()->GetTree()->Branch("ThetaCM", &mThetaCM);
    RootOutput::getInstance()->GetTree()->Branch("BeamEnergy", &mEBeam, "BeamEnergy/D");
    RootOutput::getInstance()->GetTree()->Branch("BeamTheta", &mThetaBeam, "BeamTheta/D");
    RootOutput::getInstance()->GetTree()->Branch("TimeCorr", &mTimeCorr,"TimeCorr/D");
    //mNormalThetaTarget
    //mNormalThetaM2
    RootOutput::getInstance()->GetTree()->Branch("Must2Telescopes", &mMust2Telescopes);
    RootOutput::getInstance()->GetTree()->Branch("Must2SiE", &mMust2SiE);
    RootOutput::getInstance()->GetTree()->Branch("Must2CsIE", &mMust2CsIE);
    RootOutput::getInstance()->GetTree()->Branch("Must2SiT", &mMust2SiT);
    RootOutput::getInstance()->GetTree()->Branch("Must2PointsX", &mMust2PointsX);
    RootOutput::getInstance()->GetTree()->Branch("Must2PointsY", &mMust2PointsY);
    RootOutput::getInstance()->GetTree()->Branch("Must2PointsZ", &mMust2PointsZ);
    // RootOutput::getInstance()->GetTree()->Branch("Must2Time", &mMust2Time, "Must2Time/D");
    // RootOutput::getInstance()->GetTree()->Branch("Must2SiE", &mMust2SiE, "Must2SiE/D");
    // RootOutput::getInstance()->GetTree()->Branch("Must2CsI", &mMust2CsIE, "Must2CsI/D");
    // RootOutput::getInstance()->GetTree()->Branch("BeamLength", &mBeamLength, "BeamLength/D"); 
    // RootOutput::getInstance()->GetTree()->Branch("ParticleLength", &mTrackLength, "ParticleLength/D");
    RootOutput::getInstance()->GetTree()->Branch("RunMajor", &mRunMajor, "RunMajor/I");
    RootOutput::getInstance()->GetTree()->Branch("RunMinor", &mRunMinor, "RunMinor/I");
    RootOutput::getInstance()->GetTree()->Branch("GATCONF", &mGATCONF, "GATCONF/s");
    RootOutput::getInstance()->GetTree()->Branch("T_CATS1_CAV_Cal", &mCATS1Calibrated, "T_CATS1_CAV_Cal/s");
    /*  RootOutput::getInstance()->GetTree()->Branch("ADC_CHIO_V15",&vADC_CHIO_V15,"ADC_CHIO_V15/s");
        RootOutput::getInstance()->GetTree()->Branch("ADC_VOIE_29",&vADC_VOIE_29,"ADC_VOIE_29/s");
        RootOutput::getInstance()->GetTree()->Branch("CHIO",&vCHIO,"CHIO/s");
        RootOutput::getInstance()->GetTree()->Branch("CONFDEC",&vCONFDEC,"CONFDEC/s");
        RootOutput::getInstance()->GetTree()->Branch("CONFDEC_AGAVA",&vCONFDEC_AGAVA,"CONFDEC_AGAVA/s");
        RootOutput::getInstance()->GetTree()->Branch("DATATRIG",&vDATATRIG,"DATATRIG/s");
        RootOutput::getInstance()->GetTree()->Branch("DATATRIG_CHIO",&vDATATRIG_CHIO,"DATATRIG_CHIO/s");
        RootOutput::getInstance()->GetTree()->Branch("E1D6",&vE1D6,"E1D6/s");
        RootOutput::getInstance()->GetTree()->Branch("E2D6",&vE2D6,"E2D6/s");
        RootOutput::getInstance()->GetTree()->Branch("ED4",&vED4,"ED4/s");
        RootOutput::getInstance()->GetTree()->Branch("EXL_HF",&vEXL_HF,"EXL_HF/s");
        RootOutput::getInstance()->GetTree()->Branch("GALD4X",&vGALD4X,"GALD4X/s");
        RootOutput::getInstance()->GetTree()->Branch("GALD4Y",&vGALD4Y,"GALD4Y/s");
        RootOutput::getInstance()->GetTree()->Branch("QCaviar",&vQCaviar,"QCaviar/s");
        RootOutput::getInstance()->GetTree()->Branch("QPlast",&vQPlast,"QPlast/s");
        RootOutput::getInstance()->GetTree()->Branch("TCAVHF",&vTCAVHF,"TCAVHF/s");
        RootOutput::getInstance()->GetTree()->Branch("TE1D6CAV",&vTE1D6CAV,"TE1D6CAV/s");
        RootOutput::getInstance()->GetTree()->Branch("TE1D6GAL",&vTE1D6GAL,"TE1D6GAL/s");
        RootOutput::getInstance()->GetTree()->Branch("TE1D6HF",&vTE1D6HF,"TE1D6HF/s");
        RootOutput::getInstance()->GetTree()->Branch("TED4HF",&vTED4HF,"TED4HF/s");
        RootOutput::getInstance()->GetTree()->Branch("TGALD4HF",&vTGALD4HF,"TGALD4HF/s");
        RootOutput::getInstance()->GetTree()->Branch("T_CATS1_2",&vT_CATS1_2,"T_CATS1_2/s");
        RootOutput::getInstance()->GetTree()->Branch("T_CATS1_CAV",&vT_CATS1_CAV,"T_CATS1_CAV/s");
        RootOutput::getInstance()->GetTree()->Branch("T_MUVI_CATS1",&vT_MUVI_CATS1,"T_MUVI_CATS1/s");
        RootOutput::getInstance()->GetTree()->Branch("T_PL_CATS1",&vT_PL_CATS1,"T_PL_CATS1/s");
        RootOutput::getInstance()->GetTree()->Branch("T_PL_CATS2",&vT_PL_CATS2,"T_PL_CATS2/s");
        RootOutput::getInstance()->GetTree()->Branch("T_PL_CHIO",&vT_PL_CHIO,"T_PL_CHIO/s");
        RootOutput::getInstance()->GetTree()->Branch("T_PLchCATS1",&vT_PLchCATS1,"T_PLchCATS1/s");
    */
}

////////////////////////////////////////////////////////////////////////////////
void Analysis::InitInputBranch(){
    /* RootInput:: getInstance()->GetChain()->SetBranchStatus("InitialConditions",true ); */
    /* RootInput:: getInstance()->GetChain()->SetBranchStatus("fIC_*",true ); */
    /* RootInput:: getInstance()->GetChain()->SetBranchStatus("InitialConditions",true ); */
  
    RootInput:: getInstance()->GetChain()->SetBranchAddress("GATCONF",&mGATCONF);
    /* RootInput:: getInstance()->GetChain()->SetBranchAddress("ADC_CHIO_V15",&vADC_CHIO_V15); 
       RootInput:: getInstance()->GetChain()->SetBranchAddress("ADC_VOIE_29",&vADC_VOIE_29);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("CHIO",&vCHIO);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("CONFDEC",&vCONFDEC);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("CONFDEC_AGAVA",&vCONFDEC_AGAVA);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("DATATRIG",&vDATATRIG);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("DATATRIG_CHIO",&vDATATRIG_CHIO);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("E1D6",&vE1D6);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("E2D6",&vE2D6);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("ED4",&vED4);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("EXL_HF",&vEXL_HF);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("GALD4X",&vGALD4X);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("GALD4Y",&vGALD4Y);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("QCaviar",&vQCaviar);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("QPlast",&vQPlast);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("TCAVHF",&vTCAVHF);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("TE1D6CAV",&vTE1D6CAV);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("TE1D6GAL",&vTE1D6GAL);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("TE1D6HF",&vTE1D6HF);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("TED4HF",&vTED4HF);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("TGALD4HF",&vTGALD4HF);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("T_CATS1_2",&vT_CATS1_2);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("T_CATS1_CAV",&vT_CATS1_CAV);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("T_MUVI_CATS1",&vT_MUVI_CATS1);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("T_PL_CATS1",&vT_PL_CATS1);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("T_PL_CATS2",&vT_PL_CATS2);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("T_PL_CHIO",&vT_PL_CHIO);
       RootInput:: getInstance()->GetChain()->SetBranchAddress("T_PLchCATS1",&vT_PLchCATS1);
    */
}

////////////////////////////////////////////////////////////////////////////////     
void Analysis::ReInitValue(){
    ResetMVariables();
    // mEx = -1000 ;
    // ELab = -1000;
    // ThetaLab = -1000;
    // ThetaCM = -1000;
    // OriginalThetaLab = -1000;
    // OriginalELab = -1000;
    // TimeCorr=-1000;
    // BeamLength=-1000;
    // ParticleLength=-1000;
    // run_minor=-1000;
    // run_major=-1000;
    // BeamEnergy=-1000;
    // vT_CATS1_CAV_Cal = -1000;
}

void Analysis::ResetMVariables()
{
    int initVal {-1000};
    ////////////
    mEx.clear();
    mELab.clear();
    mThetaLab.clear();
    mThetaCM.clear();
    mEBeam = initVal;
    mThetaBeam = initVal;
    ////////////////////////
    // mNormalThetaTarget = initVal;
    // mNormalThetaM2 = initVal;
    ////////////////////////
    mMust2Telescopes.clear();
    mMust2SiE.clear();
    mMust2CsIE.clear();
    mMust2SiT.clear();
    mMust2PointsX.clear();
    mMust2PointsY.clear();
    mMust2PointsZ.clear();
    // mMust2Time = initVal;
    // mMust2SiE = initVal;
    // mMust2CsIE = initVal;
    ////////////////////////
    // mBeamLength = initVal;
    // mTrackLength = initVal;
    mTimeCorr = initVal;
    mRunMinor = initVal;
    mRunMajor = initVal;
    mCATS1Calibrated = initVal;
    mGATCONF = initVal;
}

double Analysis::ComputeXYZVectorAngle(const XYZVector& v1,
                                       const XYZVector& v2)
{
    //reproduce the same calculus as TVector3
    double ptot2 {v1.Mag2() * v2.Mag2()};
    if(ptot2 <= 0)
        return 0.;
    else
    {
        double arg {v1.Dot(v2) / TMath::Sqrt(ptot2)};
        if(arg > 1.)
            arg = 1.;
        if(arg < -1.)
            arg = -1.;
        return TMath::ACos(arg);
    }
}

double Analysis::ComputeGamma(double vInSIUnits)
{
    double beta {vInSIUnits / TMath::C()};
    double gamma {1. / TMath::Sqrt(1. - beta * beta)};
    return gamma;
}

double Analysis::ComputeELossInCATS(double initEBeam, double thetaBeam)
{
    //1. Mylar
    double E {fBeamMylar.Slow(initEBeam, 1.2 * micrometer, thetaBeam)};
    //2. Isobutane
    E = fBeamIsobutane.Slow(E, 1. / 3 * cm, thetaBeam);
    //3. Mylar again
    E = fBeamMylar.Slow(E, 0.9 * micrometer, thetaBeam);
    //4. Again iC4H10
    E = fBeamIsobutane.Slow(E, 1. / 3 * cm, thetaBeam);
    //5. 3rd Mylar
    E = fBeamMylar.Slow(E, 0.9 * micrometer, thetaBeam);
    //6. 3rd isobutane...
    E = fBeamIsobutane.Slow(E, 1. / 3 * cm, thetaBeam);
    //7. Finally, last mylar
    E = fBeamMylar.Slow(E, 1.2 * micrometer, thetaBeam);
    return E;
}

double Analysis::ComputeTimeCorrectionInCATS(double EBeam, double MBeam,
                                             const XYZPoint& p0, const XYZPoint& p1)
{
    //Velocity
    double gamma {1. + EBeam / MBeam};
    double beta {TMath::Sqrt(1 - 1. / (gamma * gamma))};
    double v {beta  * TMath::C() * 1.E-6};//m/s to mm/ns
    //Distance
    auto dist {(p1 - p0).R()};
    return dist / v;
}
////////////////////////////////////////////////////////////////////////////////
//            Construct Method to be pass to the DetectorFactory              //
////////////////////////////////////////////////////////////////////////////////
NPL::VAnalysis* Analysis::Construct(){
    return (NPL::VAnalysis*) new Analysis();
}

////////////////////////////////////////////////////////////////////////////////
//            Registering the construct method to the factory                 //
////////////////////////////////////////////////////////////////////////////////
extern "C"{
    class proxy{
    public:
        proxy(){
            NPL::AnalysisFactory::getInstance()->SetConstructor(Analysis::Construct);
        }
    };

    proxy p;
}

